# Разработка под архитектуру ARM

## Кросс-компиляция

Процесс сборки программ, предназначенных для другой процессорной архитектуры или операционной системы называется кросс-компиляцией.

Для этого необходимо специальная версия компилятора `gcc`,
предназначенного для другой платформы. Во многих дистрибутивах существуют отдельные пакеты компилятора для других платформ, включая ARM.

Кроме того, для архитектуры ARM можно скачать готовую
поставку "все-в-одном" из проекта Linaro: [http://releases.linaro.org/components/toolchain/binaries/7.3-2018.05/arm-linux-gnueabi/](http://releases.linaro.org/components/toolchain/binaries/7.3-2018.05/arm-linux-gnueabi/).

Полные названия команд `gcc` имеют вид *триплетов*:
```
ARCH-OS[-VENDOR]-gcc
ARCH-OS[-VENDOR]-g++
ARCH-OS[-VENDOR]-gdb

и т. д.
```
где `ARCH` - это имя архитектуры: `i686`, `x86_64`, `arm`, `ppc` и т.д.; `OS` - целевая операционная система, например `linux`, `win32` или `darwin`; а необязательный фрагмент триплета `VENDOR` - соглашения по бинарному интерфейсу, если их для платформы существует несколько, например для ARM это может быть `gnueabi` (стандартное соглашение Linux) или `none-eabi` (без операционной системы, просто голое железо).

Для ARM ещё часто различают название архитектуры на `arm`
(soft float) и `armhf` (hard float). В первом случае подразумевается отсутствие блока с плавающей точкой, поэтому
все операции эмулируются программно, во втором случае - выполняются аппаратно.


## Выполнение программ для не родных архитектур

Выполнение программ, предназначенных для других архитектур, возможно только интерпретацией инородного набора команд. Для этого предназначены специальные программы - *эмуляторы*.

Архитектуру ARM, как и многие другие архитектуры, поддерживает эмулятор [QEMU](https://www.qemu.org/).

Эмулировать можно как компьютерную систему целиком, по аналогии с VirtualBox, так и только набор команд процессора, используя при этом окружение хост-системы Linux.

### Запуск бинарников ARM в родном окружении

Этот эмулятор входит в состав всех распространенных дистрибутивов. Команды qemu имеют вид:
```
qemu-ARCH
qemu-system-ARCH
```

где `ARCH` - это имя эмулируемой архитектуры. Команды, в названии которых присутствует `system`, запускают эмуляцию компьютерной системы, и для их использования необходимо установить операционную систему.

Команды без `system` требуют в качестве обязательного аргумента имя выполняемого файла для ОС Linux, и эмулируют  только набор команд процессора в *пользовательском режиме*, выполняя "инородный" исполняемых файл так, как будто это обычная программа.

Поскольку большинство программ, скомпилированных для ARM Linux, подразумевают использование стандартной библиотеки Си, необходимо использовать именно версию glibc для ARM. Минимальное окружение с необходимыми библиотеками можно взять из проекта Linaro (см. ссылку выше), и скормить его qemu с помощью опции `-L ПУТЬ_К_SYSROOT`.

Пример компиляции и запуска:
```
# в предположении, что компилятор распакован в /opt/arm-gcc,
# а sysroot - в /opt/arm-sysroot

# Компилируем
> /opt/arm-gcc/bin/arm-linux-gnueabi-gcc -marm -o program hello.c

# На выходе получаем исполняемый файл, который не запустится
> ./program
bash: ./program: cannot execute binary file: Exec format error

# Но мы можем запустить его с помощью qemu-arm
> qemu-arm -L /opt/arm-sysroot ./program
Hello, World!

```

### Запуск ARM-программ в эмуляции окружения Raspberry Pi

Идеальный вариант для тестирования и отладки - это использовать настоящее железо, например Raspberry Pi.

Если под рукой нет компьютера с ARM-процессором, то можно
выполнять эмуляцию ПК с установленной системой Raspbian.

Скачать образ можно отсюда: [гуглодиск](https://drive.google.com/open?id=11lc_f-_crhP-CJi_FEYb4DE0u9TMViT4)
