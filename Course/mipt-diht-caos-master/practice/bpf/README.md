# Berkley Packet Filter

Основной класс задач, в которых применяется чтение из RAW-сокетов, - это мониторинг системы. При этом возникает проблема большого потока данных, который необходимо обрабатывать, и постоянное переключение контекста между выполнением кода в пространстве ядра и в пространстве пользователя существенно снижает производительность.

Поскольку принимать нужно не все пакеты, проходящие через сетевой интерфейс, а только те, которые соответствуют некоторым критериям, то логично перенести логику фильтрации в адресное пространство ядра, а затем получать от ядра только те пакеты, которые не отвергнуты фильтром.

В качестве примера использования можно рассмотреть утилиту `tcpdump`, которая принимает в качестве аргумента текстовую строку, описывающую функцию фильтрации, и отображает только те события, которые соответствуют фильтру. В своей реализации утилита `tcpdump` использует BPF.

Дополнительные материалы (English only):

* Документация из поставки ядра Linux: [Linux Socket Filtering aka Berkley Packet Filter (BPF)](https://github.com/torvalds/linux/blob/v5.6/Documentation/networking/filter.txt)
* [man 2 bpf ](http://man7.org/linux/man-pages/man2/bpf.2.html)
* [BPF and XDP Reference Guide](https://cilium.readthedocs.io/en/latest/bpf/#bpf-and-xdp-reference-guide)

## Классический BPF: Linux Socket Filter

### Мониторинг сети и задача фильтрации

Рассмотрим задачу фильрации пакетов на уровне Data Link Layer, и будем отлавливать те из них, которые соответствуют некоторому критерию. Для простоты можно рассмотреть IPv4/UDP-сообщения к определенному DNS-серверу, - такие запросы будет легко отлаживать.

Создадим Data-Link сокет, и свяжем его с определенным сетевым интерфейсом, например `eth0`:

```c
int sock = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));

/* Не забываем проверять ошибки! Packet-сокет невозможно создать, 
не имея права root или настроенный CAP_NET_RAW */
if (-1==sock) { perror("socket"); exit(1); } 

/* Далее нужно связать сокет с определенным сетевым интерфейсом */
struct ifreq req;
memset(&req, 0, sizeof(req));
strncpy(req.ifr_name, "eth0", IFNAMSIZ);
ioctl(sock, SIOCGIFINDEX, &req, sizeof(req)); // определяем индекс eth0

/* Для Data-Link Layer нужно заполнить только часть полей адреса,
остальные должны быть инициализированы нулями */
struct sockaddr_ll addr;
memset(&addr, 0, sizeof(addr));
addr.sll_family = AF_PACKET;  // указываем, что структура для PACKET
addr.sll_protocol = htons(ETH_P_ALL);  // нас интересует только Ethernet
addr.sll_ifindex = req.ifr_ifindex; // индекс устройства (см. выше)

/* Привязываем сокет к определенному адресу. Если не вызывать bind,
то нужно использовать recvfrom и sendto с явным указанием адреса */
if (-1==bind(sock, (struct sockaddr*)&addr, sizeof(addr))) {
    perror("bind"); exit(1);
}
```

Теперь можно наблюдать за тем, что проходит через этот сетевой интерфейс.

```c
for (;;) {
    char buffer[4096];
    memset(buffer, 0, sizeof(buffer));
    
    /* Читаем блок данных из сетевого устройства */
    size_t cnt = recv(sock, buffer, sizeof(buffer), 0);

    uint32_t from_ip, to_ip;

    /* Извлекаем адреса источника и получателя из заголовка IPv4 */
    memcpy(&from_ip, buffer+26, sizeof(from_ip));
    memcpy(&to_ip, buffer+30, sizeof(to_ip));

    char from_addr[20], to_addr[20];
    memset(from_addr, 0, sizeof(from_addr));
    memset(to_addr, 0, sizeof(to_addr));
    inet_ntop(AF_INET, &from_ip, from_addr, sizeof(from_addr));
    inet_ntop(AF_INET, &to_ip, to_addr, sizeof(to_addr));

    printf("Got communication from %s to %s\n", from_addr, to_addr);
}
```

На реально используемой системе можно будет наблюдать огромное количество пакетов сетевого взаимодействия. 

### Виртуальная машина Classic-BPF

Программа фильтрации, загружаемая в ядро, состоит из набора 64-битных RISC-команд, которые выполняются виртуальной машиной, либо могут быть транслированы в нативный код. 

Каждая инструкция кодируется следующим образом:

```c
struct sock_filter {	
	__u16	code;   // 16 бит - код команды
	__u8	jt;     // 8 бит - смещение для true/jump-инструкций
	__u8	jf;     // 8 бит - смещение для false/jump-инструкций
	__u32	k;      // 32 бит - поле для произвольных данных
};
```

У виртуальной машины есть только два 32-битных регистра: аккумулятор `A`, над которым можно выолнять произвольные действия, и счетчик инструкций `X`. Возможен доступ к "памяти", при этом адресуется содержимое исследуемого сетевого пакета.

Поскольку виртуальная машина была спроектирована по аналогии с реально существующим процессором Motorola 6502, то для этого набора команд существует язык ассемблера. Программная реализация ассемблера BPF находится в поставке исходных текстах ядра Linux: `tools/bpf/bpf_asm`. 

#### Команды ассемблера BPF

* Перемещение данных: 
  - загрузить в регистр `A`: `ld` - слово, `ldh` - полуслово, `ldb` - байт;
  - сохранить значение в памяти: `st` для регистра `A`, `stx` для регистра `X`;
  - перемещение между регистрами: `tax` - из `A` в `X`, `txa` - из `X` в `A`
* Арифметические операции над регистром `A`: `add`, `sub`, `mul`, `div`, `mod`, `neg`, `and`, `or`, `xor`, `lsh`, `rsh` 
* Переходы на метку:
  * `jmp` - безусловный переход;
  * `jeq`, `jne`, `jlt`, `jle`, `jgt`, `jge` - условный переход, при этом можно опционально указать вторую метку, на которую будет выполнен переход в случае не выполнения условия
* Завершение работы: команда `ret` завершает работу и возвращает результат обработки фильтра.

#### Пример программы на cBPF

Рассмотрим задачу фильтрации Ethernet-фреймов: будем принимать только фреймы, внутри которых содержатся UDP-сообщения, адресованные DNS Google по адресу `8.8.8.8`. 

```asm
filter_google_dns:
    ldh     [12]                ; 16-бит значение после двух MAC-адресов
    jne     #0x0800, fail       ; проверяем, что внутри кадра у нас IPv4-пакет
    ldb     [23]                ; 8-бит значение типа протокола в заголовке IP
    jne     #17, fail           ; 17 - это UDP, 6 - это TCP
    ld      [30]                ; 4-байтное значение IP-адреса
    jne     #0x08080808, fail   ; сравниваем с адресом 8.8.8.8
success:
    ret     #-1                 ; значение -1 == 0xFFFFFFFF
fail:
    ret     #0                  ; значение  0
```

Данная программа проверяет, что внутри Ethernet-фрейма содержится действительно IPv4-пакет, который, в свою очередь, содержит сообщение типа UDP, и адресован получателю `8.8.8.8`. Возвращаемое значение - это максимальное количество байт, которое фильтр должен пропустить. Таким образом, значение `0` означает отклонение пакета, а максимально возможное беззнаковое целочисленное значение - пропуск пакета целиком.

### Загрузка программы-фильтра в ядро 

К сокету можно прикрепить BPF-фильтр, используя системный вызов `setsockopt`:

```c
setsockopt(
    sock,         		// файловый дескриптор сокета
    SOL_SOCKET,   		// опция предназначена для сокета в целом
    SO_ATTACH_FILTER,	// команда "присоединить фильтр"
    
    // указатель на структуру, которая содержит cBPF-программу
    struct *sock_fprog program,
    // размер аргумента; требуется как generic-параметр для setsockopt
    sizeof(struct sock_fprog)
);
```

Сама структура программы состоит из двух полей: указателя на последовательность инструкций, и количество инструкций (не байт!) в программе. Каждая инструкция - это 8 байт, которые можно описать структурой `struct sock_filter`. 

Ассемблер BPF, который имеется в составе исходных текстов ядра Linux, имеет опцию для вывода байткода в формате Си-структур, и этот вывод можно включить в код препроцессором.

```bash
> linux-5.15/tools/bpf/bpf_asm -c filter.s >filter.inc
```

```c
struct sock_filter[] code = {
    #incldue "filter.inc"   
    /*
    Здесь препроцессор вставит как есть текст вывода ассемблера:
    { 0x28,  0,  0, 0x0000000c },
    { 0x15,  0,  5, 0x00000800 },
    { 0x30,  0,  0, 0x00000017 },
    { 0x15,  0,  3, 0x00000011 },
    { 0x20,  0,  0, 0x0000001e },
    { 0x15,  0,  1, 0x08080808 },
    { 0x06,  0,  0, 0xffffffff },
    { 0x06,  0,  0, 0000000000 },
    */
};

struct sock_fprog program = {
    .filter = code,   // указатель на последовательность инструкций

    /* Количество инструкций можно рассчитать как размер всех
    инструкций в байтах, деленный на размер одной инструкции */
    .len = sizeof(code)/sizeof(code[0])
};
```

Загрузка программы подразумевает её обязательную проверку верификатором, который проверяет, что: 1) все инструкции в программе корректны; 2) размер программы не превышает 4096 инструкций; 3) программа не содержит циклов.

В случае отклонения программы верификатором, системный вызов `setsockopt` вернёт значение `-1`.

## Linux Extended BPF

Начиная с ядра 3.19 в ядре Linux появилась новая реализация BPF, которая реализует виртуальную машину со следующими свойствами:

* 11 регистров вместо 2, 10 из них - общего назначения
* все регистры - 64-битные
* появился стек, таким образом можно делать вложенные функции
* вызовы некоторых встроенных функций в адресном пространстве ядра.

Начиная с версии ядра 4.1, кроме возможности фильтрации сетевых пакетов, виртуальная машина EBPF позволяет выполнять код при наступлении определенных событий ядра. 

Кроме того, EBPF-программы могут использовать постоянные хранилища данных (`maps`), которые доступны также из адресного пространства процесса: массивы и хеш-таблицы.

Таким образом, область применения расширилась до трассировки и измерения производительности.

### Системный вызов bpf

```c
int bpf(
    // Команда взаимодействия с подсистемой EBPF
    int cmd,
    // Аргумент команды
    union bpf_attr *attr,
    // Размер аргумента команды
    unsigned int size
);
```

Использование системного вызова `bpf` на момент 02 апреля 2020 подразумевает использование функции `syscall`, поскольку Си-оболочка для него не реализована в `glibc`. Кроме того, многие возможности пока ещё не задокументированы.

Основные команды для `bpf`:

* `BPF_PROG_LOAD` - загрузить программу в ядро, и проверить её верификатором; возвращает дескриптор программы
* `BPF_MAP_CREATE`, и другие команды `BPF_MAP_*` - создание постоянного хранилища, и операции над ним.

Для каждой команды существует отдельная структура аргумента, описанная в `<linux/bpf.h>`.

Программы, в свою очередь, могут быть разными по назначению:

* `BPF_PROG_TYPE_SOCKET_FILTER` - простой фильтр, как в Classic BPF
* `BPF_PROG_TYPE_KPROBE` - программа для обработки событий ядра `kprobe`
* `BPF_PROG_TYPE_XDP` - продвинутая фильтрация пакетов как в файрволе
* [и ещё много типов - см `<uapi/linux/bpf.h>`]

Программа должна содержать функцию - точку входа, единственным аргументом которой, в регистре `R1`, будет указатель на контекст выполнения, тип которого зависит от типа программы.

### Загрузка программы

Программа (возможно) загружается в ядро системы после вызова `bpf`:

```c
/* Приходится использовать syscall, т.к. нет оболочки в glibc */
int program_id = syscall(  
    SYS_bpf,               // номер системного вызова bpf
    BPF_PROG_LOAD,         // команда для загрузки программы
    &bpf_argument,         // указатель на аргумент команды
    sizeof(bpf_argument)   // ... и размер аргумента
);

/* В случае успеха, будет возвращен файловый дескриптор программы.
   Для освобождения ресурсов, когда программа станет не нужна,
   нужно использовать обычный close() */

close(program_id);
```

Аргумент команды для загрузки - это структура (точнее, объявленная как `union`), в которой должны быть заполнены поля:

```c
char bpf_code[4096*8] = ....;
char loader_log[65535];

union bpf_attr bpf_argument = {
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,  // тип программы
    .insns = bpf_code,                         // указатель на бинарный код
    .insn_cnt = sizeof(bpf_code) / 8,          // количество инструкций
    .log_level = 1,                            // вести ли лог загрузки?
    .log_buf = loader_log,                     // куда писать лог загрузки
    .log_size = sizeof(loader_log),            // размер буфера для лога
    .license = "GPL"                           // должна быть GPL-совместимая
};
```

Лог загрузки содержит текст, который очень полезен при отладке, поскольку не любая программа будет считаться корректной с точки зрения верификатора.

Загруженную программу, если это фильтр для сокета, можно прикрутить к сокету:

```c
setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &program_id, sizeof(program_id));
```

### Байт-код EBPF-программ

Формат EBPF программ отличается от Classic BPF, поэтому использовать старый ассемблер не получится.

Формат инструкции:

```c
struct bpf_insn {
    __u8  code,        // 8-бит код команды
    __u8  dst_reg:4,   // 4-бит регистр-назначение 
    __u8  src_ref:4,   // 4-бит регистр-источник
    __s16 off,         // 16-бит значение для относительного адреса
    __s32 imm          // 32-бит значение для кодирования констант
};
```

### Компиляция EBPF-программ 

Компилировать EBPF-программы можно с помощью свежих версий тулкита CLang/LLVM. Необходимо проверить, что LLVM поддерживает цель `bpf`:

```
> llc --version
LLVM (http://llvm.org/):
  LLVM version 9.0.1
  Optimized build.
  Default target: x86_64-unknown-linux-gnu
  Host CPU: skylake

  Registered Targets:
     ......
    bpf        - BPF (host endian)
     ......
```

Рассмотрим компиляцию тривиальной программы, которая запрещает все пакеты:

```c
/* trivial.c */
int trivial_socket_filter(void *ctx) {
    return 0;  // change to -1 to allow all
}
```

Скомпилируем эту программу в объектный файл для цели `bpf`:

```
> clang -c -target bpf trivial.c
```

В результате получим объектный файл, который содержит примерно такой код:

```
> llvm-objdump -d trivial.o
trivial.o:      file format ELF64-BPF

Disassembly of section .text:

0000000000000000 trivial_socket_filter:
       0:       7b 1a f8 ff 00 00 00 00 *(u64 *)(r10 - 8) = r1
       1:       b7 00 00 00 00 00 00 00 r0 = 0
       2:       95 00 00 00 00 00 00 00 exit
```

Нулевая инструкция загружает в стек переменную `ctx`, первая присваивает значение `r0 = 0` (по соглашению о вызовах, это возвращаемое значение), а вторая выполняет выход из функции.

Для того, извлечь из объектного файла кусок кода, можно использовать утилиту `objcopy`. В дальнейшем этот код можно будет загрузить в программу как простые бинарные данные.

```bash
> llvm-objcopy     \    # требуется использовать objcopy из поставки LLVM
         -O binary \    # выходной формат - бинарный
         -j .text  \    # копируем только секцию .text
         trivial.o \    # имя входного файла
         trivial.bin    # имя файла с результатом
```

С помощью `objcopy` можно получить бинарный файл размером 24 байта, который содержит только код (ровно три инструкции), но не заголовки и таблицы.

```
> hexdump -C trivial.bin
00000000  7b 1a f8 ff 00 00 00 00  b7 00 00 00 00 00 00 00  |{...............|
00000010  95 00 00 00 00 00 00 00                           |........|
00000018
```

### Ограничения на EBPF-программы

Как и в случае с Classic BPF, загружаемые в ядро программы проходят строгую валидацию. Размер программы может составлять 4096 инструкций (до Linux 5.1), либо до миллиона инструкций (начиная с версии Linux 5.1). 

Так же валидатор проверяет, что программа гарантированно завершится за конечное время, поэтому использовать циклы в Си-программах можно только если на этапе компиляции известно число итераций. Для того, чтобы компилятор "развернул" циклы в длинную линейную программу, нужно перед циклом указать директиву `#pragma unroll` и указать опцию компиляции `-funroll-loops`.

Функции стандартной Си-библиотеки становятся не доступны, поскольку программа выполняется в ограниченном окружении. Тем не менее, есть набор функций, доступных для EBPF-программ, они перечислены в [man 7 bpf-helpers](http://man7.org/linux/man-pages/man7/bpf-helpers.7.html).

Ещё одним ограничением является порядок доступа к данным в памяти. Например, он должен быть выровненным, и вполне безобидная конструкция не пройдёт проверку валидатором:

```c
ctx = 0;   // начало пакета
unsigned int ip_dest = *(unsigned int*)(ctx+30); // извлекаем IP-адрес
```

Вывод лога валидатора:

```
6: (61) r1 = *(u32 *)(r1 +30)
invalid bpf_context access off=30 size=4
```

Поэтому приходится использовать низкоуровневые LLVM-функции для доступа к данным напрямую:

```c
/* llvm builtin functions that eBPF C program may use to
 * emit BPF_LD_ABS and BPF_LD_IND instructions
 */
unsigned long long load_byte(void *skb,
                             unsigned long long off) asm("llvm.bpf.load.byte");
unsigned long long load_half(void *skb,
                             unsigned long long off) asm("llvm.bpf.load.half");
unsigned long long load_word(void *skb,
                             unsigned long long off) asm("llvm.bpf.load.word");
```

## BPF Compiler Collection

See tutorial: [bcc Python Developer Tutorial](https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md)



