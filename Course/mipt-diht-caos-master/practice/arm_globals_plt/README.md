# Адресация данных в памяти и использование библиотечных функций

* [Reference по ARM](../asm/arm_basics/arm_reference.pdf)

## Основные команды

Как свойственно классической RISC-архитектуре, процессор ARM
может выполнять операции только над регистрами. Для доступа к памяти используются отдельные команды *загрузки* (`ldr`) и
*сохранения* (`str`).

Общий вид команд:
```
LDR{условие}{тип} Регистр, Адрес
STR{условие]{тип} Регистр, Адрес
```
где `{условие}` - это условие выполнения команды, может быть
пустым (см. предыдущий семинар); `{тип}` - тип данных:
 * `B` - беззнаковый байт
 * `SB` - знаковый байт
 * `H` - полуслово (16 бит)
 * `SB`- знаковое полуслово
 * `D` - двойное слово.

Если тип в названии команды не указан, то подразумевается
обычное слово. Обратите внимание, что для выполнения операций загрузки/сохранения данных, меньших, чем машинное слово, отдельно выделяются знаковые команды, которые
делают аккуратное расширение бит нулями, сохраняя при этом
старший знаковый бит.

В случае операций загрузки/сохранения пары регистров (двойное слово), регистр должен быть с четным номером. Второе машинное слово подразумевается в соседнем регистре с номером `Rn+1`.

## Адресация

Адрес имеет вид:
`[R_base {, offset}]`
где `R_base` - имя регистра, который содержит базовый адрес в памяти, а необязательный параметр `offset` - смещение относительно адреса. Итоговый адрес определяется как
`*R_base + offset`.

Смещение может быть как именем регистра, так и численной константой, закодированной в команду. Регистры обычно используются для индексации элементов массива, константы - для доступа к полям структуры или локальным переменным и аргументам относительно `[sp]`.

## Адресация полей Си-структур

По стандарту языка Си, поля в памяти структур размещаются по следующим правилам:
 * порядок полей в памяти соответствует порядку полей в описании структуры
 * размер структуры должен быть кратен размеру машинного слова
 * данные внутри машинных слов размещаются таким образом, чтобы быть прижатыми к их границам.

Таким образом, размер структуры не всегда совпадает с суммой размеров отдельных полей. Например:

```
struct A {
  char  f1; // 1 байт
  int   f2; // 4 байта
  char  f3; // 1 байт
};
// 1 + 4 + 1      = 6 байт
// size(struct A) = 12 байт
```

В данном примере поле `f1` занимает часть машинного слова, поле `f2` - имеет размер 4 байта, поэтому занимает уже следующее машинное слово, и для поля `f3` приходится использовать ещё одно. Простая перестановка полей местами позволяет сэкономить 4 байта:

```
struct A {
  char  f1; // 1 байт
  char  f3; // 1 байт
  int   f2; // 4 байта  
};
// 1 + 1 + 4      = 6 байт
// size(struct A) = 8 байт
```
В этом случае поля `f1` и `f3` занимают одно и то же машинное слово.

Компилятор GCC имеет нестандартный аттрибут `packed`, позволяющий создавать "упакованные" структуры, размер которых равен сумме размеров отдельных его полей:

```
struct A {
  char  f1; // 1 байт
  int   f2; // 4 байта
  char  f3; // 1 байт
} __attribute__((packed));
// 1 + 4 + 1      = 6 байт
// size(struct A) = 6 байт
```

## Функции стандартной Си-библиотеки

С каждой функцией, которую можно использовать извне, связана некоторая текстовая метка в таблице символов. После компиляции, запись в таблице символов определяет место в памяти, где размещается первая инструкция функции.

Функции, реализованные в разных объектных модулях, но компонуемые в один исполняемый файл, вызываются обычным образом. Способ их вызова ничем не отличается от вызова функций из одного и того же объектного модуля.

При использовании *библиотек*, они загружаются в отдельную область памяти, и на этапе компоновки адрес размещения библиотек не известен.

Более того, размещение самой программы, в общем случае, также предполагается неизвестным.

Такие функции, которые находятся в динамически загружаемых бибилиотеках, включая стандартную библиотеку Си, отображаются в таблице символов с пометкой `@plt`. Их реализация выглядит на языке ассемблера примерно следующим образом:

```
function@plt:

   // Во временный регистр IP загружаем текущий PC
   // с некоторым смещением. По этому смещению находится
   // таблица адресов реальных функций, которая заполняется
   // на этапе загрузки программы и динамических библиотек
   add  ip, pc, #0
   add  ip, ip, #OFFSET_TO_TABLE_BEGIN

   // Загружаем значение адреса из этой таблицы в PC.
   // Это приводит к тому, что переходим к выполнению
   // реальной функции.
   ldr  pc, [ip, #OFFSET_TO_FUNCTION_INDEX]
   
```

Таким образом, функции из внешних библиотек разполагаются как бы в самой программе, но представляют собой "трамплин" для выполнения реальной функций.
